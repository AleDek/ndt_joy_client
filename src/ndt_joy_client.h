#include "ros/ros.h"
#include "boost/thread.hpp"
#include "geometry_msgs/PoseStamped.h"
#include "geometry_msgs/TwistStamped.h"
#include "boost/thread.hpp"

//---mavros_msgs
#include "mavros_msgs/State.h"
#include "mavros_msgs/CommandBool.h"
#include "mavros_msgs/CommandTOL.h"
#include <mavros_msgs/PositionTarget.h>
//---
#include "utils.h"
#include "Eigen/Dense"
#include <Eigen/Geometry>
#include <Eigen/StdVector>
//---

#include <mutex>          // std::mutex
#include "visualization_msgs/MarkerArray.h"
#include "sensor_msgs/Joy.h"
#include "sensor_msgs/Imu.h"
#include <ros/package.h>
#include <iostream>
#include <fstream>
#include "geometry_msgs/Twist.h"
#include "geometry_msgs/Pose.h"

#include "ndt_core_interface/deploy.h"
#include "ndt_core_interface/close.h"
#include "ndt_core_interface/reset_bias.h"
#include "ndt_core_interface/disable_motors.h"
#include "ndt_core_interface/enable_motors.h"
#include "ndt_core_interface/enable_admittance.h"
#include "ndt_core_interface/interaction_mode.h"
#include "geometry_msgs/WrenchStamped.h"
#include "std_msgs/Int32.h"
#include "std_msgs/Float32.h"

#include <message_filters/subscriber.h>
#include <message_filters/synchronizer.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <sensor_msgs/Range.h>
#include "Iir.h"

using namespace Eigen;
using namespace std;

enum ARM_STATUS { POSITION, ADMITTANCE, INTERACTION};

enum SM_STATUS {    LAND,
                    IDLE_CLOSE, 
                    APPROACH_WALL,
                    IDLE_OPEN, 
                    PUMP,
                    POS_TO_ADM, 
                    GO_CONTACT,
                    ADM_TO_FORCE,
                    MEASUREMENT,
                    FORCE_TO_ADM,
                    LEAVE_WALL,
                    GO_TO_HOME};


class SIMPLE_CLIENT {


    public:
        SIMPLE_CLIENT();
        void mavros_setpoint_publisher();
		void run();
		void localization_cb ( geometry_msgs::PoseStampedConstPtr msg );
		void mavros_state_cb( mavros_msgs::State mstate);
        void joy_cb( sensor_msgs::JoyConstPtr j );
        void joy_ctrl();
        // void raise(); 
        void main_loop();
        void sensorWrench_cb(geometry_msgs::WrenchStamped msg);
        void forceSetpointRise(double riseTime, double desX);
        void traj_compute_scalar(double p_i, double p_f);
        void sm_loop(); //task state machine

        
        void range_l_cb(const sensor_msgs::RangeConstPtr &range_left_msg);
        void range_r_cb(const sensor_msgs::RangeConstPtr &range_right_msg);
    private:

        ros::NodeHandle _nh;
        ros::Publisher _target_pub;
        ros::Publisher _desWrench_pub; // = n.advertise<geometry_msgs::WrenchStamped>("/NDT/des_interaction_force", 1);

        ros::Subscriber _localization_sub;
        ros::Subscriber _joy_data_sub;
        ros::Subscriber _mavros_state_sub;
        ros::Subscriber _wrench_sub;


        ros::Subscriber _range_l_sub;
        ros::Subscriber _range_r_sub;
        // ros::Publisher _wall_pose_pub;
        ros::Publisher _wall_pose_filtered_pub;
        ros::Publisher _wall_xb_sp_pub;

        Iir::Butterworth::LowPass<2> _butt_wall_x; //filter for wall pos measurement
        Iir::Butterworth::LowPass<2> _butt_wall_yaw;


        bool _first_local_pos;
        bool _enable_joy;
        bool _joy_ctrl;
        bool _joy_ctrl_active;
        bool _enable_openarm;
        bool _enable_closearm;     //remain to initialize ancd check 
        bool _enable_admittance;
        bool _enable_interaction;
        bool _enable_home;
        bool _enable_pump;
        bool _enable_next_step;
        bool _first_wrench;
        double _currForce;
        

        // wall approach control
        // bool _enable_wall_ctrl; //TODO remove
        bool _green_light_for_ctrl;
        bool _wall_ctrl;
        bool _first_range_l;
        bool _first_range_r;
        double _range_r_val;
        double _range_l_val;
        double _range_mount_dist;
        // double _wall_xb;
        // double _wall_yaw;
        double _wall_xb_sp; //wall dist sp generated by traj
        double _wall_xb_dot_sp;
        double _wall_xb;
        double _wall_yaw;
        double _wall_error;
        double _wall_error_tresh; //min admissible track error to end trajectory
        double _contact_force_tresh; //min admissible contact force to detect wall contact

        ARM_STATUS _arm_status;
        // --- Desired state
        Vector3d _cmd_p;  // sp pos
        double _cmd_yaw;   
        Vector3d _cmd_v; // sp vel
        double _cmd_dyaw;      
        Vector3d _vel_joy; // joy input
        double _vel_joy_dyaw;
        Vector3d _w_p;  // uav fb state
        Vector4d _w_q;
        float _mes_yaw;
        mavros_msgs::State _mstate;
        
        // params
        int joy_ax0;
        int joy_ax1;
        int joy_ax2;
        int joy_ax3;

        double _wall_max_yaw;
        double _wall_max_dist;

        double _d_safe;
        double _d_approch;
        double _Kp_x;
        double _Kp_yaw;
        double _K_ff_x_dot;
        // double _Kd_x;
        // double _Kd_yaw;
        double _eps_x;
        double _eps_yaw;
        double _vx_cruise;
        double _vx_max;
        double _vyaw_max;   


};


